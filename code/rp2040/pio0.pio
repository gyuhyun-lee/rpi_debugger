.program swd
.side_set 1 // for swdclk
/*
    GPIO 0 = CLK
    GPIO 1 = DIO

            base              count
    out     1(DIO)              1
    in      1(DIO)              1
    set     1(DIO)              1 (cannot be 2, we have to preserve the DIO line)
    s-s     0(CLK)              1

    GPIO 0 = DIO
    GPIO 1 = CLK
            base              count
    out     0(DIO)              1
    in      0(DIO)              1
    set     0(DIO)              2->1 (cannot be 2, we have to preserve the DIO line)
    s-s     1(CLK)              1

    TODO(gh) for now I'm using mov x, null to change the clk line, but we might wanna find something else
    if we wanna use the x register
*/

// @-----------------------------------------------------------------------------------------------------------------------------------
//       ___        
// _____|   |___
// pssom   j                      

wait_fifo : 
    pull block side 0 // wait until there's something inside the tx fifo
    set pindirs, 0b11 side 0 

send_header_start :
    set y, 7 side 0
    // TODO(gh) make the other sm to generate the square wave 
loop_header : 
    out pins, 1 side 0 // no autopull
    mov x, null side 1 [2]
    jmp y--, loop_header side 0 [1]


// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     
// ___|   |___   
//  ms   m   i           
//           N

turnaround :  
    mov x, null side 0 // spend extra cycle in swdclk 0
    set pindirs, 0b10 side 1 [2] // tri-state the DIO line
    mov x, null side 0 [2]

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     ___     ___
// ___|   |___|   |___|   |___
//   i   m   i   m   i   m spL   

get_ack :
    in pins, 1 side 1 [2] // ok bit
    mov x, null side 0 [2]
    in pins, 1 side 1 [2] // wait bit
    mov x, null side 0 [2]
    in pins, 1 side 1 [2] // fault bit
    mov x, null side 0

    // pre-populate the iterator for read32/write32 routine
    set y, 31 side 0 
    push block side 0  // also resets the input bit count

    // wait for the core to move the PC 
loop_wait_for_read_write : 
    jmp loop_wait_for_read_write side 0

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___    
// ___|   |___
// sps   p 
// PP        
// set pindirs, 0b11 side 1 [2] // TODO(gh) might not work, if the DIO should be tri-stated during the turnaround cycle
// pull block side 0 [1]

// or, if the DIO should be tri-stated,  
//     ___    
// ___|   |___
// spp   m  os
// PP       NN
// pull block side 1 [2]
// mov x, null side 0 [2] 
// out pins, 1 side 0 
// set pindirs, 0b11, side 1

pre_write_turnaround : 
    pull block side 1 [2] // REQUIRED, this resets the out bitcount
    mov x, null side 0 [1] 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___  
// ___|   |___ x 32
//  os   m j

loop_write32 :
    out pins, 1 side 0 
    set pindirs, 0b11 side 1 [2] // mov x, null side 1 [2]  // 
    mov x, null side 0
    jmp y--, loop_write32 side 0 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___  
// ___|   |___ 
// j o   s   j
// P
post_write_parity : 
    out pins, 1 side 1 [2] // will autopull from the FIFO
    set pindirs, 0b10 side 0 [2] // tri-state dio // TODO(gh) delay is probablly not necessary here
    jmp wait_fifo side 0

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___            
// ___|   |___ x 32
//  pi   m  ji
//  P                   
// pin direction is implied to be 0, as the previous stage is ack input

loop_read32: 
    in pins, 1 side 1 [2] // will autopush at the end(32bits)
    mov x, null side 0[1]
    jmp y--, loop_read32 side 0 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     
// ___|   |___
//  jj   p
//  P    N

post_read_turnaround_and_push :  
    jmp wait_fifo side 0 [2] // we rely on the fact that once we loop around, the next instruction would pull the clock line low
// @-----------------------------------------------------------------------------------------------------------------------------------

