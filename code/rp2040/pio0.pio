.program swd
/*
    GPIO 0 = CLK
    GPIO 1 = DIO

          base  count
    out    1      1
    in     1      1
    set    0      1 (cannot be 2, we have to preserve the DIO line)
    s-s    0      1

    TODO(gh) for now I'm using mov x, null to change the clk line, but we might wanna find something else
    if we wanna use the x register
*/

.side_set 1 // for swdclk

// @-----------------------------------------------------------------------------------------------------------------------------------
//       ___        
// _____/   \___   
// pssom  om j                      

wait_fifo : 
    pull block side 0 // wait until there's something inside the tx fifo
    set pindirs, 1 side 0 

send_header_start :
    set y, 7 side 0
    // TODO(gh) make the other sm to generate the square wave 
loop_header : 
    out pins, 1 side 0
    mov x, null side 1 [1]
    out pins, 1 side 1 
    mov x, null side 0
    jmp y--, loop_header side 0  

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     
// ___/   \___
// jsm   m               
// P         

turnaround :  // also consumes the OK bit from ACK 
    set pindirs, 0 side 0
    mov x, null side 1 [2]
    mov x, null side 0 [2]

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     ___     
// ___/   \___/   \___
//   i   m   i   m sp   

get_ack :
    in pins, 1 side 1 [5] // wait bit
    mov x, null side 0 [2]
    in pins, 1 side 1 [2] // fault bit
    mov x, null side 0

    // pre-populate the iterator for read32/write32 routine
    set y, 31 side 0 
    push iffull side 0 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___    
// ___/   \___
// spp   s  om
// PP       NN 

pre_write_turnaround : 
    pull noblock side 1 [2]
    set pindirs, 1 side 0 [1] 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___  
// ___/   \___ x 32
//  om   m j

loop_write32 :
    out pins, 1 side 0 
    mov x, null side 1 [2] 
    mov x, null side 0
    jmp y--, loop_write32 side 0 
    jmp wait_fifo side 0

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___            
// ___/   \___ x 32
//  pi   m  ji
//  P                   
// pin direction is implied to be 0, as the previous stage is ack input

loop_read32: 
    in pins, 1 side 1 [2]  
    mov x, null side 0[1]
    jmp y--, loop_read32 side 0 

// @-----------------------------------------------------------------------------------------------------------------------------------
//     ___     
// ___/   \___
//  jp   j
//  P

post_read_turnaround_and_push :  
    push iffull side 1 [2]
    jmp wait_fifo side 0 // TODO(gh) we probably don't need delay here?

// @-----------------------------------------------------------------------------------------------------------------------------------


