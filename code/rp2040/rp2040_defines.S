// constants 
.equ GPIO_FUNCSEL_SIO, 5
.equ GPIO_FUNCSEL_PIO0, 6
.equ GPIO_FUNCSEL_PIO1, 7

// addresses, these will be stored at the end of the instruction stream
// as they are too large
.equ RESETS_BASE, 0x4000c000 // 1 == peripheral is in reset
.equ SIO_BASE, 0xd0000000
.equ PIO1_BASE, 0x50300000

.equ RESETS_RESET_CLR, (RESETS_BASE+0x3000)
.equ RESETS_RESET_DONE_RW, (RESETS_BASE + 0x8)

// CLK
.equ CLK_BASE, 0x40008000

.equ CLK_REF_CTRL_RW, (CLK_BASE+0x30+0x0000)
.equ CLK_REF_CTRL_XOR, (CLK_BASE+0x30+0x1000)
.equ CLK_REF_CTRL_SET, (CLK_BASE+0x30+0x2000)
.equ CLK_REF_CTRL_CLR, (CLK_BASE+0x30+0x3000)

.equ CLK_REF_CTRL_RW, (CLK_BASE+0x30+0x0000)
.equ CLK_REF_CTRL_XOR, (CLK_BASE+0x30+0x1000)
.equ CLK_REF_CTRL_SET, (CLK_BASE+0x30+0x2000)
.equ CLK_REF_CTRL_CLR, (CLK_BASE+0x30+0x3000)

.equ CLK_SYS_CTRL_RW, (CLK_BASE+0x3C+0x0000)
.equ CLK_SYS_CTRL_XOR, (CLK_BASE+0x3C+0x1000)
.equ CLK_SYS_CTRL_SET, (CLK_BASE+0x3C+0x2000)
.equ CLK_SYS_CTRL_CLR, (CLK_BASE+0x3C+0x3000)

// PLL_SYS
.equ PLL_SYS_BASE,          0x40028000
.equ PLL_SYS_XOR_BASE, (PLL_SYS_BASE + 0x1000)
.equ PLL_SYS_SET_BASE, (PLL_SYS_BASE + 0x2000)
.equ PLL_SYS_CLR_BASE, (PLL_SYS_BASE + 0x3000)

.equ PLL_SYS_CS_OFFSET,            (0x0)
.equ PLL_SYS_PWR_OFFSET,           (0x4)
.equ PLL_SYS_FBDIV_INT_OFFSET,     (0x8)
.equ PLL_SYS_PRIM_OFFSET,          (0xc)
.equ PLL_SYS_CS,            (PLL_SYS_BASE + PLL_SYS_CS_OFFSET)
.equ PLL_SYS_PWR,           (PLL_SYS_BASE + PLL_SYS_PWR_OFFSET)
.equ PLL_SYS_FBDIV_INT,     (PLL_SYS_BASE + PLL_SYS_FBDIV_INT_OFFSET)
.equ PLL_SYS_PRIM,          (PLL_SYS_BASE + PLL_SYS_PRIM_OFFSET)

/* syscfg */
.equ SYSCFG_BASE, 0x40004000
.equ SYSCFG_PROC_IN_SYNC_BYPASS, (SYSCFG_BASE + 0x0c)

/* XOSC */
.equ XOSC_BASE, 0x40024000
.equ XOSC_XOR_BASE, (XOSC_BASE + 0x1000)
.equ XOSC_SET_BASE, (XOSC_BASE + 0x2000)
.equ XOSC_CLR_BASE, (XOSC_BASE + 0x3000)

.equ XOSC_CTRL_OFFSET, 0x00
.equ XOSC_STATUS_OFFSET, 0x04
.equ XOSC_STARTUP_OFFSET, 0x0C

.equ XOSC_ENABLE_VALUE, (0xfabaa0)

/* SIO */
.equ SIO_GPIO_OE_CLR_OFFSET, (0x28)
.equ SIO_GPIO_OUT_RW_OFFSET, (0x10) 
.equ SIO_GPIO_OUT_SET_OFFSET, (0x14) 
.equ SIO_GPIO_OUT_CLR_OFFSET, (0x18)  
.equ SIO_GPIO_OUT_XOR_OFFSET, (0x01c) 
.equ SIO_GPIO_OE_SET_OFFSET, (0x24) 

.equ SIO_GPIO_OUT_RW, (SIO_BASE + SIO_GPIO_OUT_RW_OFFSET) 
.equ SIO_GPIO_OUT_SET, (SIO_BASE + SIO_GPIO_OUT_SET_OFFSET) 
.equ SIO_GPIO_OUT_CLR, (SIO_BASE + SIO_GPIO_OUT_CLR_OFFSET)  
.equ SIO_GPIO_OUT_XOR, (SIO_BASE + SIO_GPIO_OUT_XOR_OFFSET) 
.equ SIO_GPIO_OE_SET, (SIO_BASE + SIO_GPIO_OE_SET_OFFSET) 
.equ SIO_GPIO_OE_CLR, (SIO_BASE + SIO_GPIO_OE_CLR_OFFSET)  

.equ SIO_GPIO_IN, (SIO_BASE + 0x004) // SIO_BASE + GPIO_IN

/*GPIO*/
.equ IO_BANK0_BASE, 0x40014000 
.equ IO_BANK0_XOR_BASE, (IO_BANK0_BASE + 0x1000)
.equ IO_BANK0_SET_BASE, (IO_BANK0_BASE + 0x2000)
.equ IO_BANK0_CLR_BASE, (IO_BANK0_BASE + 0x3000)

.equ GPIO0_CTRL_OFFSET, ((0x8 * 0) + 4)
.equ GPIO1_CTRL_OFFSET, ((0x8 * 1) + 4)
.equ GPIO2_CTRL_OFFSET, ((0x8 * 2) + 4)
.equ GPIO3_CTRL_OFFSET, ((0x8 * 3) + 4)

// interrupt enable
.equ IO_BANK0_INTE0, (IO_BANK0_BASE + 0x100)

/*PIO*/
.equ PIO0_BASE, 0x50200000

.equ PIO0_CTRL_OFFSET, (0x0)
.equ PIO0_FSTAT_OFFSET, (0x4)
.equ PIO0_FDEBUG_OFFSET, (0x8)
.equ PIO0_FLEVEL_OFFSET, (0xc)
.equ PIO0_TXF0_OFFSET, (0x10)
.equ PIO0_TXF1_OFFSET, (0x14)
.equ PIO0_TXF2_OFFSET, (0x18)
.equ PIO0_TXF3_OFFSET, (0x1c)
.equ PIO0_RXF0_OFFSET, (0x20)
.equ PIO0_RXF1_OFFSET, (0x24)
.equ PIO0_RXF2_OFFSET, (0x28)
.equ PIO0_RXF3_OFFSET, (0x2c)
.equ PIO0_IRQ_OFFSET, (0x30)
.equ PIO0_IRQ_FORCE_OFFSET, (0x34)
.equ PIO0_INPUT_SYNC_BYPASS_OFFSET, (0x38)
.equ PIO0_DBG_PADOUT_OFFSET, (0x3c)
.equ PIO0_DBG_PADOE_OFFSET, (0x40)
.equ PIO0_DBG_CFGINFO_OFFSET, (0x44)

// although each 'slot' is 4 bytes in the address space, each 'instruction' is 2 bytes
.equ PIO0_INSTR_MEM_START, (PIO0_BASE + 0x048) 
// user-defined PIO instruction location inside SRAM. At startup, debug probe should load & store the instructions
// from here to PIO0_INSTR_MEM_START
.equ PIO0_INSTR_MEM_SRARM_START, 0x20040000 // sram bank 4 for now 

.equ SM0_TXF, (PIO0_BASE + 0x10)
.equ SM1_TXF, (PIO0_BASE + 0x14)
.equ SM2_TXF, (PIO0_BASE + 0x18)
.equ SM3_TXF, (PIO0_BASE + 0x1c)

.equ SM0_RXF, (PIO0_BASE + 0x20)
.equ SM1_RXF, (PIO0_BASE + 0x24)
.equ SM2_RXF, (PIO0_BASE + 0x28)
.equ SM3_RXF, (PIO0_BASE + 0x2c)

.equ SM0_BASE, (PIO0_BASE + 0x0c8)
.equ SM0_XOR_BASE, (SM0_BASE + 0x1000) 
.equ SM0_SET_BASE, (SM0_BASE + 0x2000) 
.equ SM0_CLR_BASE, (SM0_BASE + 0x3000) 

.equ SM1_BASE, (PIO0_BASE + 0x0e0) 
.equ SM1_XOR_BASE, (SM1_BASE + 0x1000) 
.equ SM1_SET_BASE, (SM1_BASE + 0x2000) 
.equ SM1_CLR_BASE, (SM1_BASE + 0x3000) 

.equ SM_CLKDIV_OFFSET, (0x0) 
.equ SM_EXECCTRL_OFFSET, (0x4) 
.equ SM_SHIFTCTRL_OFFSET, (0x8) // out/in shift registers control
.equ SM_ADDR_OFFSET, (0xc) // RO
.equ SM_INSTR_OFFSET, (0x10) // write to change the SM's
.equ SM_PINCTRL_OFFSET, (0x14)

.equ SM_PINCTRL_OUT_BASE_SHIFT, 0
.equ SM_PINCTRL_SET_BASE_SHIFT, 5
.equ SM_PINCTRL_SIDESET_BASE_SHIFT, 10
.equ SM_PINCTRL_IN_BASE_SHIFT, 15
.equ SM_PINCTRL_OUT_COUNT_SHIFT, 20
.equ SM_PINCTRL_SET_COUNT_SHIFT, 26
.equ SM_PINCTRL_SIDESET_COUNT_SHIFT, 29

















